/**
 * <copyright>
 * </copyright>
 *
 * $Id$
 */
package CleanUML.util;

import CleanUML.AggregationKind;
import CleanUML.AntiRigidMixinClass;
import CleanUML.AntiRigidSortalClass;
import CleanUML.Association;
import CleanUML.Category;
import CleanUML.Characterization;
import CleanUML.Classifier;
import CleanUML.CleanUMLPackage;
import CleanUML.Collective;
import CleanUML.Comment;
import CleanUML.Constraint;
import CleanUML.DataType;
import CleanUML.Dependency;
import CleanUML.DependencyRelationship;
import CleanUML.Derivation;
import CleanUML.DirectedBinaryAssociation;
import CleanUML.DirectedRelationship;
import CleanUML.Element;
import CleanUML.ElementImport;
import CleanUML.Enumeration;
import CleanUML.EnumerationLiteral;
import CleanUML.Expression;
import CleanUML.Feature;
import CleanUML.FormalAssociation;
import CleanUML.Generalization;
import CleanUML.GeneralizationSet;
import CleanUML.InstanceSpecification;
import CleanUML.InstanceValue;
import CleanUML.Kind;
import CleanUML.LiteralBoolean;
import CleanUML.LiteralInteger;
import CleanUML.LiteralNull;
import CleanUML.LiteralSpecification;
import CleanUML.LiteralString;
import CleanUML.LiteralUnlimitedNatural;
import CleanUML.MaterialAssociation;
import CleanUML.Mediation;
import CleanUML.Meronymic;
import CleanUML.Mixin;
import CleanUML.MixinClass;
import CleanUML.Mode;
import CleanUML.Model;
import CleanUML.MomentClass;
import CleanUML.MultiplicityElement;
import CleanUML.NamedElement;
import CleanUML.Namespace;
import CleanUML.NonRigidMixinClass;
import CleanUML.ObjectClass;
import CleanUML.OpaqueExpression;
import CleanUML.PackageImport;
import CleanUML.PackageMerge;
import CleanUML.PackageableElement;
import CleanUML.Phase;
import CleanUML.PrimitiveType;
import CleanUML.Property;
import CleanUML.Quantity;
import CleanUML.RedefinableElement;
import CleanUML.Relationship;
import CleanUML.Relator;
import CleanUML.RigidMixinClass;
import CleanUML.RigidSortalClass;
import CleanUML.Role;
import CleanUML.RoleMixin;
import CleanUML.SemiRigidMixinClass;
import CleanUML.Slot;
import CleanUML.SortalClass;
import CleanUML.StringExpression;
import CleanUML.StructuralFeature;
import CleanUML.SubKind;
import CleanUML.SubstanceSortal;
import CleanUML.Type;
import CleanUML.TypedElement;
import CleanUML.ValueSpecification;
import CleanUML.VisibilityKind;
import CleanUML.componentOf;
import CleanUML.memberOf;
import CleanUML.subCollectionOf;
import CleanUML.subQuantityOf;

import java.util.Map;

import org.eclipse.emf.common.util.DiagnosticChain;
import org.eclipse.emf.common.util.ResourceLocator;

import org.eclipse.emf.ecore.EPackage;

import org.eclipse.emf.ecore.util.EObjectValidator;

/**
 * <!-- begin-user-doc -->
 * The <b>Validator</b> for the model.
 * <!-- end-user-doc -->
 * @see CleanUML.CleanUMLPackage
 * @generated
 */
public class CleanUMLValidator extends EObjectValidator {
	/**
	 * The cached model package
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final CleanUMLValidator INSTANCE = new CleanUMLValidator();

	/**
	 * A constant for the {@link org.eclipse.emf.common.util.Diagnostic#getSource() source} of diagnostic {@link org.eclipse.emf.common.util.Diagnostic#getCode() codes} from this package.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @see org.eclipse.emf.common.util.Diagnostic#getSource()
	 * @see org.eclipse.emf.common.util.Diagnostic#getCode()
	 * @generated
	 */
	public static final String DIAGNOSTIC_SOURCE = "CleanUML";

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Not own self' of 'Element'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int ELEMENT__NOT_OWN_SELF = 1;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Has owner' of 'Element'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int ELEMENT__HAS_OWNER = 2;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Elements public or private' of 'Package'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int PACKAGE__ELEMENTS_PUBLIC_OR_PRIVATE = 3;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Has no qualified name' of 'Named Element'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int NAMED_ELEMENT__HAS_NO_QUALIFIED_NAME = 4;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Has qualified name' of 'Named Element'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int NAMED_ELEMENT__HAS_QUALIFIED_NAME = 5;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Visibility needs ownership' of 'Named Element'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int NAMED_ELEMENT__VISIBILITY_NEEDS_OWNERSHIP = 6;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Members distinguishable' of 'Namespace'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int NAMESPACE__MEMBERS_DISTINGUISHABLE = 7;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Visibility public or private' of 'Element Import'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int ELEMENT_IMPORT__VISIBILITY_PUBLIC_OR_PRIVATE = 8;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Imported element is public' of 'Element Import'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int ELEMENT_IMPORT__IMPORTED_ELEMENT_IS_PUBLIC = 9;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Public or private' of 'Package Import'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int PACKAGE_IMPORT__PUBLIC_OR_PRIVATE = 10;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Not apply to self' of 'Constraint'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int CONSTRAINT__NOT_APPLY_TO_SELF = 11;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Value specification boolean' of 'Constraint'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int CONSTRAINT__VALUE_SPECIFICATION_BOOLEAN = 12;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Boolean value' of 'Constraint'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int CONSTRAINT__BOOLEAN_VALUE = 13;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No side effects' of 'Constraint'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int CONSTRAINT__NO_SIDE_EFFECTS = 14;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Not applied to self' of 'Constraint'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int CONSTRAINT__NOT_APPLIED_TO_SELF = 15;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Specialized end number' of 'Association'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int ASSOCIATION__SPECIALIZED_END_NUMBER = 16;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Specialized end types' of 'Association'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int ASSOCIATION__SPECIALIZED_END_TYPES = 17;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Binary associations' of 'Association'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int ASSOCIATION__BINARY_ASSOCIATIONS = 18;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Association ends' of 'Association'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int ASSOCIATION__ASSOCIATION_ENDS = 19;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No cycles in generalization' of 'Classifier'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int CLASSIFIER__NO_CYCLES_IN_GENERALIZATION = 20;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Generalization hierarchies' of 'Classifier'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int CLASSIFIER__GENERALIZATION_HIERARCHIES = 21;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Specialize type' of 'Classifier'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int CLASSIFIER__SPECIALIZE_TYPE = 22;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Maps to generalization set' of 'Classifier'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int CLASSIFIER__MAPS_TO_GENERALIZATION_SET = 23;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Redefinition context valid' of 'Redefinable Element'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int REDEFINABLE_ELEMENT__REDEFINITION_CONTEXT_VALID = 24;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Redefinition consistent' of 'Redefinable Element'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int REDEFINABLE_ELEMENT__REDEFINITION_CONSISTENT = 25;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Generalization same classifier' of 'Generalization'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int GENERALIZATION__GENERALIZATION_SAME_CLASSIFIER = 26;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Generalization same classifier' of 'Generalization Set'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int GENERALIZATION_SET__GENERALIZATION_SAME_CLASSIFIER = 27;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Maps to generalization set' of 'Generalization Set'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int GENERALIZATION_SET__MAPS_TO_GENERALIZATION_SET = 28;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Language body size' of 'Opaque Expression'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int OPAQUE_EXPRESSION__LANGUAGE_BODY_SIZE = 29;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Only return result parameters' of 'Opaque Expression'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int OPAQUE_EXPRESSION__ONLY_RETURN_RESULT_PARAMETERS = 30;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'One return result parameter' of 'Opaque Expression'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int OPAQUE_EXPRESSION__ONE_RETURN_RESULT_PARAMETER = 31;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Lower ge 0' of 'Multiplicity Element'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int MULTIPLICITY_ELEMENT__LOWER_GE_0 = 32;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Upper ge lower' of 'Multiplicity Element'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int MULTIPLICITY_ELEMENT__UPPER_GE_LOWER = 33;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Value specification no side effects' of 'Multiplicity Element'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int MULTIPLICITY_ELEMENT__VALUE_SPECIFICATION_NO_SIDE_EFFECTS = 34;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Value specification constant' of 'Multiplicity Element'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int MULTIPLICITY_ELEMENT__VALUE_SPECIFICATION_CONSTANT = 35;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity of composite' of 'Property'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int PROPERTY__MULTIPLICITY_OF_COMPOSITE = 36;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Subsetting context conforms' of 'Property'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int PROPERTY__SUBSETTING_CONTEXT_CONFORMS = 37;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Redefined property inherited' of 'Property'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int PROPERTY__REDEFINED_PROPERTY_INHERITED = 38;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Subsetting rules' of 'Property'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int PROPERTY__SUBSETTING_RULES = 39;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Navigable readonly' of 'Property'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int PROPERTY__NAVIGABLE_READONLY = 40;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Derived union is derived' of 'Property'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int PROPERTY__DERIVED_UNION_IS_DERIVED = 41;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Derived union is read only' of 'Property'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int PROPERTY__DERIVED_UNION_IS_READ_ONLY = 42;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Subsetted property names' of 'Property'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int PROPERTY__SUBSETTED_PROPERTY_NAMES = 43;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Deployment target' of 'Property'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int PROPERTY__DEPLOYMENT_TARGET = 44;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Binding to attribute' of 'Property'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int PROPERTY__BINDING_TO_ATTRIBUTE = 45;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Passive class' of 'Class'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int CLASS__PASSIVE_CLASS = 46;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Operands' of 'String Expression'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int STRING_EXPRESSION__OPERANDS = 47;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Subexpressions' of 'String Expression'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int STRING_EXPRESSION__SUBEXPRESSIONS = 48;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Defining feature' of 'Instance Specification'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int INSTANCE_SPECIFICATION__DEFINING_FEATURE = 49;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Structural feature' of 'Instance Specification'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int INSTANCE_SPECIFICATION__STRUCTURAL_FEATURE = 50;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Deployment target' of 'Instance Specification'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int INSTANCE_SPECIFICATION__DEPLOYMENT_TARGET = 51;

	/**
	 * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Deployment artifact' of 'Instance Specification'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public static final int INSTANCE_SPECIFICATION__DEPLOYMENT_ARTIFACT = 52;

	/**
	 * A constant with a fixed name that can be used as the base value for additional hand written constants.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	private static final int GENERATED_DIAGNOSTIC_CODE_COUNT = 52;

	/**
	 * A constant with a fixed name that can be used as the base value for additional hand written constants in a derived class.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	protected static final int DIAGNOSTIC_CODE_COUNT = GENERATED_DIAGNOSTIC_CODE_COUNT;

	/**
	 * Creates an instance of the switch.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public CleanUMLValidator() {
		super();
	}

	/**
	 * Returns the package of this validator switch.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	protected EPackage getEPackage() {
	  return CleanUMLPackage.eINSTANCE;
	}

	/**
	 * Calls <code>validateXXX</code> for the corresonding classifier of the model.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	@Override
	protected boolean validate(int classifierID, Object value, DiagnosticChain diagnostics, Map<Object, Object> context) {
		switch (classifierID) {
			case CleanUMLPackage.COMMENT:
				return validateComment((Comment)value, diagnostics, context);
			case CleanUMLPackage.ELEMENT:
				return validateElement((Element)value, diagnostics, context);
			case CleanUMLPackage.PACKAGE:
				return validatePackage((CleanUML.Package)value, diagnostics, context);
			case CleanUMLPackage.PACKAGEABLE_ELEMENT:
				return validatePackageableElement((PackageableElement)value, diagnostics, context);
			case CleanUMLPackage.NAMED_ELEMENT:
				return validateNamedElement((NamedElement)value, diagnostics, context);
			case CleanUMLPackage.DEPENDENCY:
				return validateDependency((Dependency)value, diagnostics, context);
			case CleanUMLPackage.DIRECTED_RELATIONSHIP:
				return validateDirectedRelationship((DirectedRelationship)value, diagnostics, context);
			case CleanUMLPackage.RELATIONSHIP:
				return validateRelationship((Relationship)value, diagnostics, context);
			case CleanUMLPackage.NAMESPACE:
				return validateNamespace((Namespace)value, diagnostics, context);
			case CleanUMLPackage.ELEMENT_IMPORT:
				return validateElementImport((ElementImport)value, diagnostics, context);
			case CleanUMLPackage.PACKAGE_IMPORT:
				return validatePackageImport((PackageImport)value, diagnostics, context);
			case CleanUMLPackage.CONSTRAINT:
				return validateConstraint((Constraint)value, diagnostics, context);
			case CleanUMLPackage.VALUE_SPECIFICATION:
				return validateValueSpecification((ValueSpecification)value, diagnostics, context);
			case CleanUMLPackage.TYPED_ELEMENT:
				return validateTypedElement((TypedElement)value, diagnostics, context);
			case CleanUMLPackage.TYPE:
				return validateType((Type)value, diagnostics, context);
			case CleanUMLPackage.ASSOCIATION:
				return validateAssociation((Association)value, diagnostics, context);
			case CleanUMLPackage.CLASSIFIER:
				return validateClassifier((Classifier)value, diagnostics, context);
			case CleanUMLPackage.REDEFINABLE_ELEMENT:
				return validateRedefinableElement((RedefinableElement)value, diagnostics, context);
			case CleanUMLPackage.GENERALIZATION:
				return validateGeneralization((Generalization)value, diagnostics, context);
			case CleanUMLPackage.GENERALIZATION_SET:
				return validateGeneralizationSet((GeneralizationSet)value, diagnostics, context);
			case CleanUMLPackage.FEATURE:
				return validateFeature((Feature)value, diagnostics, context);
			case CleanUMLPackage.OPAQUE_EXPRESSION:
				return validateOpaqueExpression((OpaqueExpression)value, diagnostics, context);
			case CleanUMLPackage.MULTIPLICITY_ELEMENT:
				return validateMultiplicityElement((MultiplicityElement)value, diagnostics, context);
			case CleanUMLPackage.PROPERTY:
				return validateProperty((Property)value, diagnostics, context);
			case CleanUMLPackage.CLASS:
				return validateClass((CleanUML.Class)value, diagnostics, context);
			case CleanUMLPackage.MODEL:
				return validateModel((Model)value, diagnostics, context);
			case CleanUMLPackage.DATA_TYPE:
				return validateDataType((DataType)value, diagnostics, context);
			case CleanUMLPackage.STRUCTURAL_FEATURE:
				return validateStructuralFeature((StructuralFeature)value, diagnostics, context);
			case CleanUMLPackage.STRING_EXPRESSION:
				return validateStringExpression((StringExpression)value, diagnostics, context);
			case CleanUMLPackage.EXPRESSION:
				return validateExpression((Expression)value, diagnostics, context);
			case CleanUMLPackage.PACKAGE_MERGE:
				return validatePackageMerge((PackageMerge)value, diagnostics, context);
			case CleanUMLPackage.ENUMERATION:
				return validateEnumeration((Enumeration)value, diagnostics, context);
			case CleanUMLPackage.ENUMERATION_LITERAL:
				return validateEnumerationLiteral((EnumerationLiteral)value, diagnostics, context);
			case CleanUMLPackage.INSTANCE_SPECIFICATION:
				return validateInstanceSpecification((InstanceSpecification)value, diagnostics, context);
			case CleanUMLPackage.SLOT:
				return validateSlot((Slot)value, diagnostics, context);
			case CleanUMLPackage.PRIMITIVE_TYPE:
				return validatePrimitiveType((PrimitiveType)value, diagnostics, context);
			case CleanUMLPackage.LITERAL_SPECIFICATION:
				return validateLiteralSpecification((LiteralSpecification)value, diagnostics, context);
			case CleanUMLPackage.LITERAL_INTEGER:
				return validateLiteralInteger((LiteralInteger)value, diagnostics, context);
			case CleanUMLPackage.LITERAL_STRING:
				return validateLiteralString((LiteralString)value, diagnostics, context);
			case CleanUMLPackage.LITERAL_BOOLEAN:
				return validateLiteralBoolean((LiteralBoolean)value, diagnostics, context);
			case CleanUMLPackage.LITERAL_NULL:
				return validateLiteralNull((LiteralNull)value, diagnostics, context);
			case CleanUMLPackage.INSTANCE_VALUE:
				return validateInstanceValue((InstanceValue)value, diagnostics, context);
			case CleanUMLPackage.LITERAL_UNLIMITED_NATURAL:
				return validateLiteralUnlimitedNatural((LiteralUnlimitedNatural)value, diagnostics, context);
			case CleanUMLPackage.OBJECT_CLASS:
				return validateObjectClass((ObjectClass)value, diagnostics, context);
			case CleanUMLPackage.MOMENT_CLASS:
				return validateMomentClass((MomentClass)value, diagnostics, context);
			case CleanUMLPackage.SORTAL_CLASS:
				return validateSortalClass((SortalClass)value, diagnostics, context);
			case CleanUMLPackage.MIXIN_CLASS:
				return validateMixinClass((MixinClass)value, diagnostics, context);
			case CleanUMLPackage.RIGID_SORTAL_CLASS:
				return validateRigidSortalClass((RigidSortalClass)value, diagnostics, context);
			case CleanUMLPackage.ANTI_RIGID_SORTAL_CLASS:
				return validateAntiRigidSortalClass((AntiRigidSortalClass)value, diagnostics, context);
			case CleanUMLPackage.SUBSTANCE_SORTAL:
				return validateSubstanceSortal((SubstanceSortal)value, diagnostics, context);
			case CleanUMLPackage.SUB_KIND:
				return validateSubKind((SubKind)value, diagnostics, context);
			case CleanUMLPackage.KIND:
				return validateKind((Kind)value, diagnostics, context);
			case CleanUMLPackage.QUANTITY:
				return validateQuantity((Quantity)value, diagnostics, context);
			case CleanUMLPackage.COLLECTIVE:
				return validateCollective((Collective)value, diagnostics, context);
			case CleanUMLPackage.PHASE:
				return validatePhase((Phase)value, diagnostics, context);
			case CleanUMLPackage.ROLE:
				return validateRole((Role)value, diagnostics, context);
			case CleanUMLPackage.RIGID_MIXIN_CLASS:
				return validateRigidMixinClass((RigidMixinClass)value, diagnostics, context);
			case CleanUMLPackage.NON_RIGID_MIXIN_CLASS:
				return validateNonRigidMixinClass((NonRigidMixinClass)value, diagnostics, context);
			case CleanUMLPackage.CATEGORY:
				return validateCategory((Category)value, diagnostics, context);
			case CleanUMLPackage.ANTI_RIGID_MIXIN_CLASS:
				return validateAntiRigidMixinClass((AntiRigidMixinClass)value, diagnostics, context);
			case CleanUMLPackage.SEMI_RIGID_MIXIN_CLASS:
				return validateSemiRigidMixinClass((SemiRigidMixinClass)value, diagnostics, context);
			case CleanUMLPackage.ROLE_MIXIN:
				return validateRoleMixin((RoleMixin)value, diagnostics, context);
			case CleanUMLPackage.MIXIN:
				return validateMixin((Mixin)value, diagnostics, context);
			case CleanUMLPackage.MODE:
				return validateMode((Mode)value, diagnostics, context);
			case CleanUMLPackage.RELATOR:
				return validateRelator((Relator)value, diagnostics, context);
			case CleanUMLPackage.DIRECTED_BINARY_ASSOCIATION:
				return validateDirectedBinaryAssociation((DirectedBinaryAssociation)value, diagnostics, context);
			case CleanUMLPackage.MERONYMIC:
				return validateMeronymic((Meronymic)value, diagnostics, context);
			case CleanUMLPackage.SUB_QUANTITY_OF:
				return validatesubQuantityOf((subQuantityOf)value, diagnostics, context);
			case CleanUMLPackage.SUB_COLLECTION_OF:
				return validatesubCollectionOf((subCollectionOf)value, diagnostics, context);
			case CleanUMLPackage.MEMBER_OF:
				return validatememberOf((memberOf)value, diagnostics, context);
			case CleanUMLPackage.COMPONENT_OF:
				return validatecomponentOf((componentOf)value, diagnostics, context);
			case CleanUMLPackage.DEPENDENCY_RELATIONSHIP:
				return validateDependencyRelationship((DependencyRelationship)value, diagnostics, context);
			case CleanUMLPackage.CHARACTERIZATION:
				return validateCharacterization((Characterization)value, diagnostics, context);
			case CleanUMLPackage.MEDIATION:
				return validateMediation((Mediation)value, diagnostics, context);
			case CleanUMLPackage.DERIVATION:
				return validateDerivation((Derivation)value, diagnostics, context);
			case CleanUMLPackage.FORMAL_ASSOCIATION:
				return validateFormalAssociation((FormalAssociation)value, diagnostics, context);
			case CleanUMLPackage.MATERIAL_ASSOCIATION:
				return validateMaterialAssociation((MaterialAssociation)value, diagnostics, context);
			case CleanUMLPackage.VISIBILITY_KIND:
				return validateVisibilityKind((VisibilityKind)value, diagnostics, context);
			case CleanUMLPackage.AGGREGATION_KIND:
				return validateAggregationKind((AggregationKind)value, diagnostics, context);
			case CleanUMLPackage.INTEGER:
				return validateInteger(((Integer)value).intValue(), diagnostics, context);
			case CleanUMLPackage.BOOLEAN:
				return validateBoolean(((Boolean)value).booleanValue(), diagnostics, context);
			case CleanUMLPackage.STRING:
				return validateString((String)value, diagnostics, context);
			case CleanUMLPackage.UNLIMITED_NATURAL:
				return validateUnlimitedNatural(((Integer)value).intValue(), diagnostics, context);
			default: 
				return true;
		}
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateComment(Comment comment, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(comment, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(comment, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(comment, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(comment, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(comment, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(comment, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(comment, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(comment, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(comment, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateElement(Element element, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(element, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(element, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(element, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(element, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(element, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(element, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(element, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(element, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(element, diagnostics, context);
		return result;
	}

	/**
	 * Validates the not_own_self constraint of '<em>Element</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateElement_not_own_self(Element element, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return element.not_own_self(diagnostics, context);
	}

	/**
	 * Validates the has_owner constraint of '<em>Element</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateElement_has_owner(Element element, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return element.has_owner(diagnostics, context);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validatePackage(CleanUML.Package package_, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(package_, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(package_, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(package_, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(package_, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(package_, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(package_, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(package_, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(package_, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(package_, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(package_, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(package_, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(package_, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(package_, diagnostics, context);
		if (result || diagnostics != null) result &= validatePackage_elements_public_or_private(package_, diagnostics, context);
		return result;
	}

	/**
	 * Validates the elements_public_or_private constraint of '<em>Package</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validatePackage_elements_public_or_private(CleanUML.Package package_, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return package_.elements_public_or_private(diagnostics, context);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validatePackageableElement(PackageableElement packageableElement, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(packageableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(packageableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(packageableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(packageableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(packageableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(packageableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(packageableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(packageableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(packageableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(packageableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(packageableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(packageableElement, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateNamedElement(NamedElement namedElement, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(namedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(namedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(namedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(namedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(namedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(namedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(namedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(namedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(namedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(namedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(namedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(namedElement, diagnostics, context);
		return result;
	}

	/**
	 * Validates the has_no_qualified_name constraint of '<em>Named Element</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateNamedElement_has_no_qualified_name(NamedElement namedElement, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return namedElement.has_no_qualified_name(diagnostics, context);
	}

	/**
	 * Validates the has_qualified_name constraint of '<em>Named Element</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateNamedElement_has_qualified_name(NamedElement namedElement, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return namedElement.has_qualified_name(diagnostics, context);
	}

	/**
	 * Validates the visibility_needs_ownership constraint of '<em>Named Element</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateNamedElement_visibility_needs_ownership(NamedElement namedElement, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return namedElement.visibility_needs_ownership(diagnostics, context);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateDependency(Dependency dependency, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(dependency, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(dependency, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(dependency, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(dependency, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(dependency, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(dependency, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(dependency, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(dependency, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(dependency, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(dependency, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(dependency, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(dependency, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateDirectedRelationship(DirectedRelationship directedRelationship, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(directedRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(directedRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(directedRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(directedRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(directedRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(directedRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(directedRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(directedRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(directedRelationship, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateRelationship(Relationship relationship, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(relationship, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(relationship, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(relationship, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(relationship, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(relationship, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(relationship, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(relationship, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(relationship, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(relationship, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateNamespace(Namespace namespace, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(namespace, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(namespace, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(namespace, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(namespace, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(namespace, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(namespace, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(namespace, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(namespace, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(namespace, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(namespace, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(namespace, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(namespace, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(namespace, diagnostics, context);
		return result;
	}

	/**
	 * Validates the members_distinguishable constraint of '<em>Namespace</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateNamespace_members_distinguishable(Namespace namespace, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return namespace.members_distinguishable(diagnostics, context);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateElementImport(ElementImport elementImport, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(elementImport, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(elementImport, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(elementImport, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(elementImport, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(elementImport, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(elementImport, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(elementImport, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(elementImport, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(elementImport, diagnostics, context);
		if (result || diagnostics != null) result &= validateElementImport_visibility_public_or_private(elementImport, diagnostics, context);
		if (result || diagnostics != null) result &= validateElementImport_imported_element_is_public(elementImport, diagnostics, context);
		return result;
	}

	/**
	 * Validates the visibility_public_or_private constraint of '<em>Element Import</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateElementImport_visibility_public_or_private(ElementImport elementImport, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return elementImport.visibility_public_or_private(diagnostics, context);
	}

	/**
	 * Validates the imported_element_is_public constraint of '<em>Element Import</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateElementImport_imported_element_is_public(ElementImport elementImport, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return elementImport.imported_element_is_public(diagnostics, context);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validatePackageImport(PackageImport packageImport, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(packageImport, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(packageImport, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(packageImport, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(packageImport, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(packageImport, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(packageImport, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(packageImport, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(packageImport, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(packageImport, diagnostics, context);
		if (result || diagnostics != null) result &= validatePackageImport_public_or_private(packageImport, diagnostics, context);
		return result;
	}

	/**
	 * Validates the public_or_private constraint of '<em>Package Import</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validatePackageImport_public_or_private(PackageImport packageImport, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return packageImport.public_or_private(diagnostics, context);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateConstraint(Constraint constraint, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(constraint, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(constraint, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(constraint, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(constraint, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(constraint, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(constraint, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(constraint, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(constraint, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(constraint, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(constraint, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(constraint, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(constraint, diagnostics, context);
		if (result || diagnostics != null) result &= validateConstraint_not_apply_to_self(constraint, diagnostics, context);
		if (result || diagnostics != null) result &= validateConstraint_value_specification_boolean(constraint, diagnostics, context);
		if (result || diagnostics != null) result &= validateConstraint_boolean_value(constraint, diagnostics, context);
		if (result || diagnostics != null) result &= validateConstraint_no_side_effects(constraint, diagnostics, context);
		if (result || diagnostics != null) result &= validateConstraint_not_applied_to_self(constraint, diagnostics, context);
		return result;
	}

	/**
	 * Validates the not_apply_to_self constraint of '<em>Constraint</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateConstraint_not_apply_to_self(Constraint constraint, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return constraint.not_apply_to_self(diagnostics, context);
	}

	/**
	 * Validates the value_specification_boolean constraint of '<em>Constraint</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateConstraint_value_specification_boolean(Constraint constraint, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return constraint.value_specification_boolean(diagnostics, context);
	}

	/**
	 * Validates the boolean_value constraint of '<em>Constraint</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateConstraint_boolean_value(Constraint constraint, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return constraint.boolean_value(diagnostics, context);
	}

	/**
	 * Validates the no_side_effects constraint of '<em>Constraint</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateConstraint_no_side_effects(Constraint constraint, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return constraint.no_side_effects(diagnostics, context);
	}

	/**
	 * Validates the not_applied_to_self constraint of '<em>Constraint</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateConstraint_not_applied_to_self(Constraint constraint, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return constraint.not_applied_to_self(diagnostics, context);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateValueSpecification(ValueSpecification valueSpecification, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(valueSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(valueSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(valueSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(valueSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(valueSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(valueSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(valueSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(valueSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(valueSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(valueSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(valueSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(valueSpecification, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateTypedElement(TypedElement typedElement, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(typedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(typedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(typedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(typedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(typedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(typedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(typedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(typedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(typedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(typedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(typedElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(typedElement, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateType(Type type, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(type, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(type, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(type, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(type, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(type, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(type, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(type, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(type, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(type, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(type, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(type, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(type, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateAssociation(Association association, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(association, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(association, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(association, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(association, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(association, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(association, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(association, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(association, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(association, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(association, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(association, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(association, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(association, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(association, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(association, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(association, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(association, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(association, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(association, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_number(association, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_types(association, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_binary_associations(association, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_association_ends(association, diagnostics, context);
		return result;
	}

	/**
	 * Validates the specialized_end_number constraint of '<em>Association</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateAssociation_specialized_end_number(Association association, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return association.specialized_end_number(diagnostics, context);
	}

	/**
	 * Validates the specialized_end_types constraint of '<em>Association</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateAssociation_specialized_end_types(Association association, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return association.specialized_end_types(diagnostics, context);
	}

	/**
	 * Validates the binary_associations constraint of '<em>Association</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateAssociation_binary_associations(Association association, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return association.binary_associations(diagnostics, context);
	}

	/**
	 * Validates the association_ends constraint of '<em>Association</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateAssociation_association_ends(Association association, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return association.association_ends(diagnostics, context);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateClassifier(Classifier classifier, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(classifier, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(classifier, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(classifier, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(classifier, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(classifier, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(classifier, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(classifier, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(classifier, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(classifier, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(classifier, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(classifier, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(classifier, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(classifier, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(classifier, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(classifier, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(classifier, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(classifier, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(classifier, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(classifier, diagnostics, context);
		return result;
	}

	/**
	 * Validates the no_cycles_in_generalization constraint of '<em>Classifier</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateClassifier_no_cycles_in_generalization(Classifier classifier, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return classifier.no_cycles_in_generalization(diagnostics, context);
	}

	/**
	 * Validates the generalization_hierarchies constraint of '<em>Classifier</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateClassifier_generalization_hierarchies(Classifier classifier, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return classifier.generalization_hierarchies(diagnostics, context);
	}

	/**
	 * Validates the specialize_type constraint of '<em>Classifier</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateClassifier_specialize_type(Classifier classifier, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return classifier.specialize_type(diagnostics, context);
	}

	/**
	 * Validates the maps_to_generalization_set constraint of '<em>Classifier</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateClassifier_maps_to_generalization_set(Classifier classifier, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return classifier.maps_to_generalization_set(diagnostics, context);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateRedefinableElement(RedefinableElement redefinableElement, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(redefinableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(redefinableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(redefinableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(redefinableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(redefinableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(redefinableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(redefinableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(redefinableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(redefinableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(redefinableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(redefinableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(redefinableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(redefinableElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(redefinableElement, diagnostics, context);
		return result;
	}

	/**
	 * Validates the redefinition_context_valid constraint of '<em>Redefinable Element</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateRedefinableElement_redefinition_context_valid(RedefinableElement redefinableElement, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return redefinableElement.redefinition_context_valid(diagnostics, context);
	}

	/**
	 * Validates the redefinition_consistent constraint of '<em>Redefinable Element</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateRedefinableElement_redefinition_consistent(RedefinableElement redefinableElement, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return redefinableElement.redefinition_consistent(diagnostics, context);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateGeneralization(Generalization generalization, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(generalization, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(generalization, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(generalization, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(generalization, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(generalization, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(generalization, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(generalization, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(generalization, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(generalization, diagnostics, context);
		if (result || diagnostics != null) result &= validateGeneralization_generalization_same_classifier(generalization, diagnostics, context);
		return result;
	}

	/**
	 * Validates the generalization_same_classifier constraint of '<em>Generalization</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateGeneralization_generalization_same_classifier(Generalization generalization, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return generalization.generalization_same_classifier(diagnostics, context);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateGeneralizationSet(GeneralizationSet generalizationSet, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(generalizationSet, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(generalizationSet, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(generalizationSet, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(generalizationSet, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(generalizationSet, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(generalizationSet, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(generalizationSet, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(generalizationSet, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(generalizationSet, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(generalizationSet, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(generalizationSet, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(generalizationSet, diagnostics, context);
		if (result || diagnostics != null) result &= validateGeneralizationSet_generalization_same_classifier(generalizationSet, diagnostics, context);
		if (result || diagnostics != null) result &= validateGeneralizationSet_maps_to_generalization_set(generalizationSet, diagnostics, context);
		return result;
	}

	/**
	 * Validates the generalization_same_classifier constraint of '<em>Generalization Set</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateGeneralizationSet_generalization_same_classifier(GeneralizationSet generalizationSet, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return generalizationSet.generalization_same_classifier(diagnostics, context);
	}

	/**
	 * Validates the maps_to_generalization_set constraint of '<em>Generalization Set</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateGeneralizationSet_maps_to_generalization_set(GeneralizationSet generalizationSet, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return generalizationSet.maps_to_generalization_set(diagnostics, context);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateFeature(Feature feature, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(feature, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(feature, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(feature, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(feature, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(feature, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(feature, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(feature, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(feature, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(feature, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(feature, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(feature, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(feature, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(feature, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(feature, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateOpaqueExpression(OpaqueExpression opaqueExpression, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(opaqueExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(opaqueExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(opaqueExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(opaqueExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(opaqueExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(opaqueExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(opaqueExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(opaqueExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(opaqueExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(opaqueExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(opaqueExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(opaqueExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validateOpaqueExpression_language_body_size(opaqueExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validateOpaqueExpression_only_return_result_parameters(opaqueExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validateOpaqueExpression_one_return_result_parameter(opaqueExpression, diagnostics, context);
		return result;
	}

	/**
	 * Validates the language_body_size constraint of '<em>Opaque Expression</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateOpaqueExpression_language_body_size(OpaqueExpression opaqueExpression, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return opaqueExpression.language_body_size(diagnostics, context);
	}

	/**
	 * Validates the only_return_result_parameters constraint of '<em>Opaque Expression</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateOpaqueExpression_only_return_result_parameters(OpaqueExpression opaqueExpression, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return opaqueExpression.only_return_result_parameters(diagnostics, context);
	}

	/**
	 * Validates the one_return_result_parameter constraint of '<em>Opaque Expression</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateOpaqueExpression_one_return_result_parameter(OpaqueExpression opaqueExpression, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return opaqueExpression.one_return_result_parameter(diagnostics, context);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateMultiplicityElement(MultiplicityElement multiplicityElement, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(multiplicityElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(multiplicityElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(multiplicityElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(multiplicityElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(multiplicityElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(multiplicityElement, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(multiplicityElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(multiplicityElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(multiplicityElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateMultiplicityElement_lower_ge_0(multiplicityElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateMultiplicityElement_upper_ge_lower(multiplicityElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateMultiplicityElement_value_specification_no_side_effects(multiplicityElement, diagnostics, context);
		if (result || diagnostics != null) result &= validateMultiplicityElement_value_specification_constant(multiplicityElement, diagnostics, context);
		return result;
	}

	/**
	 * Validates the lower_ge_0 constraint of '<em>Multiplicity Element</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateMultiplicityElement_lower_ge_0(MultiplicityElement multiplicityElement, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return multiplicityElement.lower_ge_0(diagnostics, context);
	}

	/**
	 * Validates the upper_ge_lower constraint of '<em>Multiplicity Element</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateMultiplicityElement_upper_ge_lower(MultiplicityElement multiplicityElement, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return multiplicityElement.upper_ge_lower(diagnostics, context);
	}

	/**
	 * Validates the value_specification_no_side_effects constraint of '<em>Multiplicity Element</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateMultiplicityElement_value_specification_no_side_effects(MultiplicityElement multiplicityElement, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return multiplicityElement.value_specification_no_side_effects(diagnostics, context);
	}

	/**
	 * Validates the value_specification_constant constraint of '<em>Multiplicity Element</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateMultiplicityElement_value_specification_constant(MultiplicityElement multiplicityElement, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return multiplicityElement.value_specification_constant(diagnostics, context);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateProperty(Property property, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(property, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(property, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(property, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(property, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(property, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(property, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateMultiplicityElement_lower_ge_0(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateMultiplicityElement_upper_ge_lower(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateMultiplicityElement_value_specification_no_side_effects(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateMultiplicityElement_value_specification_constant(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateProperty_multiplicity_of_composite(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateProperty_subsetting_context_conforms(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateProperty_redefined_property_inherited(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateProperty_subsetting_rules(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateProperty_navigable_readonly(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateProperty_derived_union_is_derived(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateProperty_derived_union_is_read_only(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateProperty_subsetted_property_names(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateProperty_deployment_target(property, diagnostics, context);
		if (result || diagnostics != null) result &= validateProperty_binding_to_attribute(property, diagnostics, context);
		return result;
	}

	/**
	 * Validates the multiplicity_of_composite constraint of '<em>Property</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateProperty_multiplicity_of_composite(Property property, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return property.multiplicity_of_composite(diagnostics, context);
	}

	/**
	 * Validates the subsetting_context_conforms constraint of '<em>Property</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateProperty_subsetting_context_conforms(Property property, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return property.subsetting_context_conforms(diagnostics, context);
	}

	/**
	 * Validates the redefined_property_inherited constraint of '<em>Property</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateProperty_redefined_property_inherited(Property property, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return property.redefined_property_inherited(diagnostics, context);
	}

	/**
	 * Validates the subsetting_rules constraint of '<em>Property</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateProperty_subsetting_rules(Property property, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return property.subsetting_rules(diagnostics, context);
	}

	/**
	 * Validates the navigable_readonly constraint of '<em>Property</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateProperty_navigable_readonly(Property property, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return property.navigable_readonly(diagnostics, context);
	}

	/**
	 * Validates the derived_union_is_derived constraint of '<em>Property</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateProperty_derived_union_is_derived(Property property, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return property.derived_union_is_derived(diagnostics, context);
	}

	/**
	 * Validates the derived_union_is_read_only constraint of '<em>Property</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateProperty_derived_union_is_read_only(Property property, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return property.derived_union_is_read_only(diagnostics, context);
	}

	/**
	 * Validates the subsetted_property_names constraint of '<em>Property</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateProperty_subsetted_property_names(Property property, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return property.subsetted_property_names(diagnostics, context);
	}

	/**
	 * Validates the deployment_target constraint of '<em>Property</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateProperty_deployment_target(Property property, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return property.deployment_target(diagnostics, context);
	}

	/**
	 * Validates the binding_to_attribute constraint of '<em>Property</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateProperty_binding_to_attribute(Property property, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return property.binding_to_attribute(diagnostics, context);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateClass(CleanUML.Class class_, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(class_, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(class_, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(class_, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(class_, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(class_, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(class_, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(class_, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(class_, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(class_, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(class_, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(class_, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(class_, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(class_, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(class_, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(class_, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(class_, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(class_, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(class_, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(class_, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(class_, diagnostics, context);
		return result;
	}

	/**
	 * Validates the passive_class constraint of '<em>Class</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateClass_passive_class(CleanUML.Class class_, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return class_.passive_class(diagnostics, context);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateModel(Model model, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(model, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(model, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(model, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(model, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(model, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(model, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(model, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(model, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(model, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(model, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(model, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(model, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(model, diagnostics, context);
		if (result || diagnostics != null) result &= validatePackage_elements_public_or_private(model, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateDataType(DataType dataType, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(dataType, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(dataType, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(dataType, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(dataType, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(dataType, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(dataType, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(dataType, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(dataType, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(dataType, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(dataType, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(dataType, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(dataType, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(dataType, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(dataType, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(dataType, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(dataType, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(dataType, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(dataType, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(dataType, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateStructuralFeature(StructuralFeature structuralFeature, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(structuralFeature, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(structuralFeature, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(structuralFeature, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(structuralFeature, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(structuralFeature, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(structuralFeature, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(structuralFeature, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(structuralFeature, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(structuralFeature, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(structuralFeature, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(structuralFeature, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(structuralFeature, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(structuralFeature, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(structuralFeature, diagnostics, context);
		if (result || diagnostics != null) result &= validateMultiplicityElement_lower_ge_0(structuralFeature, diagnostics, context);
		if (result || diagnostics != null) result &= validateMultiplicityElement_upper_ge_lower(structuralFeature, diagnostics, context);
		if (result || diagnostics != null) result &= validateMultiplicityElement_value_specification_no_side_effects(structuralFeature, diagnostics, context);
		if (result || diagnostics != null) result &= validateMultiplicityElement_value_specification_constant(structuralFeature, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateStringExpression(StringExpression stringExpression, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(stringExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(stringExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(stringExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(stringExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(stringExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(stringExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(stringExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(stringExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(stringExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(stringExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(stringExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(stringExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validateStringExpression_operands(stringExpression, diagnostics, context);
		if (result || diagnostics != null) result &= validateStringExpression_subexpressions(stringExpression, diagnostics, context);
		return result;
	}

	/**
	 * Validates the operands constraint of '<em>String Expression</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateStringExpression_operands(StringExpression stringExpression, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return stringExpression.operands(diagnostics, context);
	}

	/**
	 * Validates the subexpressions constraint of '<em>String Expression</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateStringExpression_subexpressions(StringExpression stringExpression, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return stringExpression.subexpressions(diagnostics, context);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateExpression(Expression expression, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(expression, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(expression, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(expression, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(expression, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(expression, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(expression, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(expression, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(expression, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(expression, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(expression, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(expression, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(expression, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validatePackageMerge(PackageMerge packageMerge, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(packageMerge, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(packageMerge, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(packageMerge, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(packageMerge, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(packageMerge, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(packageMerge, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(packageMerge, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(packageMerge, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(packageMerge, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateEnumeration(Enumeration enumeration, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(enumeration, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(enumeration, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(enumeration, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(enumeration, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(enumeration, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(enumeration, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(enumeration, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(enumeration, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(enumeration, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(enumeration, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(enumeration, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(enumeration, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(enumeration, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(enumeration, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(enumeration, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(enumeration, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(enumeration, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(enumeration, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(enumeration, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateEnumerationLiteral(EnumerationLiteral enumerationLiteral, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(enumerationLiteral, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(enumerationLiteral, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(enumerationLiteral, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(enumerationLiteral, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(enumerationLiteral, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(enumerationLiteral, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(enumerationLiteral, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(enumerationLiteral, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(enumerationLiteral, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(enumerationLiteral, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(enumerationLiteral, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(enumerationLiteral, diagnostics, context);
		if (result || diagnostics != null) result &= validateInstanceSpecification_defining_feature(enumerationLiteral, diagnostics, context);
		if (result || diagnostics != null) result &= validateInstanceSpecification_structural_feature(enumerationLiteral, diagnostics, context);
		if (result || diagnostics != null) result &= validateInstanceSpecification_deployment_target(enumerationLiteral, diagnostics, context);
		if (result || diagnostics != null) result &= validateInstanceSpecification_deployment_artifact(enumerationLiteral, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateInstanceSpecification(InstanceSpecification instanceSpecification, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(instanceSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(instanceSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(instanceSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(instanceSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(instanceSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(instanceSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(instanceSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(instanceSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(instanceSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(instanceSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(instanceSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(instanceSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validateInstanceSpecification_defining_feature(instanceSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validateInstanceSpecification_structural_feature(instanceSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validateInstanceSpecification_deployment_target(instanceSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validateInstanceSpecification_deployment_artifact(instanceSpecification, diagnostics, context);
		return result;
	}

	/**
	 * Validates the defining_feature constraint of '<em>Instance Specification</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateInstanceSpecification_defining_feature(InstanceSpecification instanceSpecification, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return instanceSpecification.defining_feature(diagnostics, context);
	}

	/**
	 * Validates the structural_feature constraint of '<em>Instance Specification</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateInstanceSpecification_structural_feature(InstanceSpecification instanceSpecification, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return instanceSpecification.structural_feature(diagnostics, context);
	}

	/**
	 * Validates the deployment_target constraint of '<em>Instance Specification</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateInstanceSpecification_deployment_target(InstanceSpecification instanceSpecification, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return instanceSpecification.deployment_target(diagnostics, context);
	}

	/**
	 * Validates the deployment_artifact constraint of '<em>Instance Specification</em>'.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateInstanceSpecification_deployment_artifact(InstanceSpecification instanceSpecification, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return instanceSpecification.deployment_artifact(diagnostics, context);
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateSlot(Slot slot, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(slot, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(slot, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(slot, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(slot, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(slot, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(slot, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(slot, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(slot, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(slot, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validatePrimitiveType(PrimitiveType primitiveType, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(primitiveType, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(primitiveType, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(primitiveType, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(primitiveType, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(primitiveType, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(primitiveType, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(primitiveType, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(primitiveType, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(primitiveType, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(primitiveType, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(primitiveType, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(primitiveType, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(primitiveType, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(primitiveType, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(primitiveType, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(primitiveType, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(primitiveType, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(primitiveType, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(primitiveType, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateLiteralSpecification(LiteralSpecification literalSpecification, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(literalSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(literalSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(literalSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(literalSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(literalSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(literalSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(literalSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(literalSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(literalSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(literalSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(literalSpecification, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(literalSpecification, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateLiteralInteger(LiteralInteger literalInteger, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(literalInteger, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(literalInteger, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(literalInteger, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(literalInteger, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(literalInteger, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(literalInteger, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(literalInteger, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(literalInteger, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(literalInteger, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(literalInteger, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(literalInteger, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(literalInteger, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateLiteralString(LiteralString literalString, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(literalString, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(literalString, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(literalString, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(literalString, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(literalString, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(literalString, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(literalString, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(literalString, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(literalString, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(literalString, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(literalString, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(literalString, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateLiteralBoolean(LiteralBoolean literalBoolean, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(literalBoolean, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(literalBoolean, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(literalBoolean, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(literalBoolean, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(literalBoolean, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(literalBoolean, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(literalBoolean, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(literalBoolean, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(literalBoolean, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(literalBoolean, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(literalBoolean, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(literalBoolean, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateLiteralNull(LiteralNull literalNull, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(literalNull, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(literalNull, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(literalNull, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(literalNull, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(literalNull, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(literalNull, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(literalNull, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(literalNull, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(literalNull, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(literalNull, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(literalNull, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(literalNull, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateInstanceValue(InstanceValue instanceValue, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(instanceValue, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(instanceValue, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(instanceValue, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(instanceValue, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(instanceValue, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(instanceValue, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(instanceValue, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(instanceValue, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(instanceValue, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(instanceValue, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(instanceValue, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(instanceValue, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateLiteralUnlimitedNatural(LiteralUnlimitedNatural literalUnlimitedNatural, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(literalUnlimitedNatural, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(literalUnlimitedNatural, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(literalUnlimitedNatural, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(literalUnlimitedNatural, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(literalUnlimitedNatural, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(literalUnlimitedNatural, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(literalUnlimitedNatural, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(literalUnlimitedNatural, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(literalUnlimitedNatural, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(literalUnlimitedNatural, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(literalUnlimitedNatural, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(literalUnlimitedNatural, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateObjectClass(ObjectClass objectClass, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(objectClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(objectClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(objectClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(objectClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(objectClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(objectClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(objectClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(objectClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(objectClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(objectClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(objectClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(objectClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(objectClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(objectClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(objectClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(objectClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(objectClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(objectClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(objectClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(objectClass, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateMomentClass(MomentClass momentClass, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(momentClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(momentClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(momentClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(momentClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(momentClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(momentClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(momentClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(momentClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(momentClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(momentClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(momentClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(momentClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(momentClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(momentClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(momentClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(momentClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(momentClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(momentClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(momentClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(momentClass, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateSortalClass(SortalClass sortalClass, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(sortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(sortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(sortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(sortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(sortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(sortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(sortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(sortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(sortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(sortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(sortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(sortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(sortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(sortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(sortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(sortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(sortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(sortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(sortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(sortalClass, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateMixinClass(MixinClass mixinClass, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(mixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(mixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(mixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(mixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(mixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(mixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(mixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(mixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(mixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(mixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(mixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(mixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(mixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(mixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(mixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(mixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(mixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(mixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(mixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(mixinClass, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateRigidSortalClass(RigidSortalClass rigidSortalClass, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(rigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(rigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(rigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(rigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(rigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(rigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(rigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(rigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(rigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(rigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(rigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(rigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(rigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(rigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(rigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(rigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(rigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(rigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(rigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(rigidSortalClass, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateAntiRigidSortalClass(AntiRigidSortalClass antiRigidSortalClass, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(antiRigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(antiRigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(antiRigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(antiRigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(antiRigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(antiRigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(antiRigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(antiRigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(antiRigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(antiRigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(antiRigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(antiRigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(antiRigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(antiRigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(antiRigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(antiRigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(antiRigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(antiRigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(antiRigidSortalClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(antiRigidSortalClass, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateSubstanceSortal(SubstanceSortal substanceSortal, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(substanceSortal, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(substanceSortal, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(substanceSortal, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(substanceSortal, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(substanceSortal, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(substanceSortal, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(substanceSortal, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(substanceSortal, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(substanceSortal, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(substanceSortal, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(substanceSortal, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(substanceSortal, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(substanceSortal, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(substanceSortal, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(substanceSortal, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(substanceSortal, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(substanceSortal, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(substanceSortal, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(substanceSortal, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(substanceSortal, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateSubKind(SubKind subKind, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(subKind, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(subKind, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(subKind, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(subKind, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(subKind, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(subKind, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(subKind, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(subKind, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(subKind, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(subKind, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(subKind, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(subKind, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(subKind, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(subKind, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(subKind, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(subKind, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(subKind, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(subKind, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(subKind, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(subKind, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateKind(Kind kind, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(kind, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(kind, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(kind, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(kind, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(kind, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(kind, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(kind, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(kind, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(kind, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(kind, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(kind, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(kind, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(kind, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(kind, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(kind, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(kind, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(kind, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(kind, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(kind, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(kind, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateQuantity(Quantity quantity, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(quantity, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(quantity, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(quantity, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(quantity, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(quantity, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(quantity, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(quantity, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(quantity, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(quantity, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(quantity, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(quantity, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(quantity, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(quantity, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(quantity, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(quantity, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(quantity, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(quantity, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(quantity, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(quantity, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(quantity, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateCollective(Collective collective, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(collective, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(collective, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(collective, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(collective, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(collective, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(collective, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(collective, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(collective, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(collective, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(collective, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(collective, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(collective, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(collective, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(collective, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(collective, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(collective, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(collective, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(collective, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(collective, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(collective, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validatePhase(Phase phase, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(phase, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(phase, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(phase, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(phase, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(phase, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(phase, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(phase, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(phase, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(phase, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(phase, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(phase, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(phase, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(phase, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(phase, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(phase, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(phase, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(phase, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(phase, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(phase, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(phase, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateRole(Role role, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(role, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(role, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(role, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(role, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(role, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(role, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(role, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(role, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(role, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(role, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(role, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(role, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(role, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(role, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(role, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(role, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(role, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(role, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(role, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(role, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateRigidMixinClass(RigidMixinClass rigidMixinClass, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(rigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(rigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(rigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(rigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(rigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(rigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(rigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(rigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(rigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(rigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(rigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(rigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(rigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(rigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(rigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(rigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(rigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(rigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(rigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(rigidMixinClass, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateNonRigidMixinClass(NonRigidMixinClass nonRigidMixinClass, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(nonRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(nonRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(nonRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(nonRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(nonRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(nonRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(nonRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(nonRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(nonRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(nonRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(nonRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(nonRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(nonRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(nonRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(nonRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(nonRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(nonRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(nonRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(nonRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(nonRigidMixinClass, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateCategory(Category category, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(category, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(category, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(category, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(category, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(category, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(category, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(category, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(category, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(category, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(category, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(category, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(category, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(category, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(category, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(category, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(category, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(category, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(category, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(category, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(category, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateAntiRigidMixinClass(AntiRigidMixinClass antiRigidMixinClass, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(antiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(antiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(antiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(antiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(antiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(antiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(antiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(antiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(antiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(antiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(antiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(antiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(antiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(antiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(antiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(antiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(antiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(antiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(antiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(antiRigidMixinClass, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateSemiRigidMixinClass(SemiRigidMixinClass semiRigidMixinClass, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(semiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(semiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(semiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(semiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(semiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(semiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(semiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(semiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(semiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(semiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(semiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(semiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(semiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(semiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(semiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(semiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(semiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(semiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(semiRigidMixinClass, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(semiRigidMixinClass, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateRoleMixin(RoleMixin roleMixin, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(roleMixin, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(roleMixin, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(roleMixin, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(roleMixin, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(roleMixin, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(roleMixin, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(roleMixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(roleMixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(roleMixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(roleMixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(roleMixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(roleMixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(roleMixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(roleMixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(roleMixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(roleMixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(roleMixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(roleMixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(roleMixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(roleMixin, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateMixin(Mixin mixin, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(mixin, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(mixin, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(mixin, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(mixin, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(mixin, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(mixin, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(mixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(mixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(mixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(mixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(mixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(mixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(mixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(mixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(mixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(mixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(mixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(mixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(mixin, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(mixin, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateMode(Mode mode, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(mode, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(mode, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(mode, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(mode, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(mode, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(mode, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(mode, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(mode, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(mode, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(mode, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(mode, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(mode, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(mode, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(mode, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(mode, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(mode, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(mode, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(mode, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(mode, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(mode, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateRelator(Relator relator, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(relator, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(relator, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(relator, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(relator, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(relator, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(relator, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(relator, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(relator, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(relator, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(relator, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(relator, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(relator, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(relator, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(relator, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(relator, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(relator, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(relator, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(relator, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(relator, diagnostics, context);
		if (result || diagnostics != null) result &= validateClass_passive_class(relator, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateDirectedBinaryAssociation(DirectedBinaryAssociation directedBinaryAssociation, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_number(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_types(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_binary_associations(directedBinaryAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_association_ends(directedBinaryAssociation, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateMeronymic(Meronymic meronymic, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_number(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_types(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_binary_associations(meronymic, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_association_ends(meronymic, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validatesubQuantityOf(subQuantityOf subQuantityOf, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_number(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_types(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_binary_associations(subQuantityOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_association_ends(subQuantityOf, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validatesubCollectionOf(subCollectionOf subCollectionOf, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_number(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_types(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_binary_associations(subCollectionOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_association_ends(subCollectionOf, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validatememberOf(memberOf memberOf, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_number(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_types(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_binary_associations(memberOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_association_ends(memberOf, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validatecomponentOf(componentOf componentOf, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_number(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_types(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_binary_associations(componentOf, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_association_ends(componentOf, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateDependencyRelationship(DependencyRelationship dependencyRelationship, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_number(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_types(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_binary_associations(dependencyRelationship, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_association_ends(dependencyRelationship, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateCharacterization(Characterization characterization, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_number(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_types(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_binary_associations(characterization, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_association_ends(characterization, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateMediation(Mediation mediation, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_number(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_types(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_binary_associations(mediation, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_association_ends(mediation, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateDerivation(Derivation derivation, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_number(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_types(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_binary_associations(derivation, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_association_ends(derivation, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateFormalAssociation(FormalAssociation formalAssociation, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_number(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_types(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_binary_associations(formalAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_association_ends(formalAssociation, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateMaterialAssociation(MaterialAssociation materialAssociation, DiagnosticChain diagnostics, Map<Object, Object> context) {
		boolean result = validate_EveryMultiplicityConforms(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryDataValueConforms(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryReferenceIsContained(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryProxyResolves(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_UniqueID(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryKeyUnique(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validate_EveryMapEntryUnique(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_not_own_self(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateElement_has_owner(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_no_qualified_name(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_has_qualified_name(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamedElement_visibility_needs_ownership(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateNamespace_members_distinguishable(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_context_valid(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateRedefinableElement_redefinition_consistent(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_no_cycles_in_generalization(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_generalization_hierarchies(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_specialize_type(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateClassifier_maps_to_generalization_set(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_number(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_specialized_end_types(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_binary_associations(materialAssociation, diagnostics, context);
		if (result || diagnostics != null) result &= validateAssociation_association_ends(materialAssociation, diagnostics, context);
		return result;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateVisibilityKind(VisibilityKind visibilityKind, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return true;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateAggregationKind(AggregationKind aggregationKind, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return true;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateInteger(int integer, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return true;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateBoolean(boolean boolean_, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return true;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateString(String string, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return true;
	}

	/**
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public boolean validateUnlimitedNatural(int unlimitedNatural, DiagnosticChain diagnostics, Map<Object, Object> context) {
		return true;
	}

} //CleanUMLValidator
